module Problem12

// What is the value of the first triangle number to have over five hundred
// divisors?
//
// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
// ten terms would be:
//
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers:
//
//     1: 1
//     3: 1,3
//     6: 1,2,3,6
//    10: 1,2,5,10
//    15: 1,3,5,15
//    21: 1,3,7,21
//    28: 1,2,4,7,14,28
// 
// We can see that 28 is the first triangle number to have over five divisors.
// 
// What is the value of the first triangle number to have over five hundred divisors?

let triangle (n:int64) =
    let rec f m a =
        if m=1L then
           a
        else
           f (m-1L) (a+m)
    f n 1L

// Testing:
//printfn "%d" (triangle 1) //  1.
//printfn "%d" (triangle 2) //  3.
//printfn "%d" (triangle 3) //  6.
//printfn "%d" (triangle 4) // 10.
//printfn "%d" (triangle 5) // 15.
//printfn "%d" (triangle 6) // 21.
//printfn "%d" (triangle 7) // 28.

let factors (n:int64) =
    let m = int64 (sqrt (float n)) in
    [1L..m]
    |> Seq.filter (fun x -> n % x = 0L)
    |> Seq.collect (fun x -> [x; n/x])

// Testing:
// printfn "%A" (factors 20L) // [1L; 2L; 4L].

let naturals = Seq.unfold (fun x -> Some (x,x+1L)) 1L

naturals |>
Seq.map triangle |>
Seq.skipWhile (fun t -> (Seq.length (factors t)) < 500) |>
Seq.head |>
printfn "%d" // 76576500.
// Real: 00:00:08.415, CPU: 00:00:08.377, GC gen0: 1136, gen1: 139, gen2: 0


// From http://theburningmonk.com/2010/09/project-euler-problem-12-solution/:

let triangle (n:int64) = [1L..n] |> Seq.sum // How simple compared to mine! :)

let factors (n:int64) =
    let m = int64 (sqrt (double n))
    [1L..m]
    |> Seq.filter (fun x -> n%x = 0L)
    |> Seq.collect (fun x -> [x; n/x])

let naturals = Seq.unfold (fun x -> Some (x,x+1L)) 1L

let answer =
    naturals
    |> Seq.map (fun x -> triangle x)
    |> Seq.filter (fun x -> Seq.length (factors x) >= 500)
    |> Seq.head // 76576500L.


// And from http://fsharp-euler.wikispaces.com/euler+012:
let numDivisor64 n =
    (* count the number of divisor d in n *)
    let rec countd n d =
        if n%d=0L then
            let n2, cnt = countd (n/d) d
            n2, cnt+1L
        else
            n, 0L
 
    (* perform (1+# of divisor 1) * (1 + # of divisor 2) ... *)
    let rec collect n d =
        if n < d then 1L
        elif n%d=0L then
            let n2, cnt = countd n d
            (cnt+1L) * (collect n2 d)
        else
            collect n (d+1L)
    collect n 2L
 
let problem12 =
    {1L..System.Int64.MaxValue}
    |> Seq.map (fun x->x*(x+1L)/2L)
    |> Seq.map (fun y->(y,numDivisor64 y))
    |> Seq.find (fun (y,n)->n>500L) // (76576500L, 576L)

// I have no idea what he's doing. But he got the same answer as the burning
// monk. So I guess my answer is incorrect.
//
// Hmph. I changed my ints to int64s, and got the same answer. I wonder why
// the other solutions use int64s.
//
// My factors, based on the burning monk's previous solutions, is not generating
// all the factors of n. That must be the problem.

printfn "%A" (factors 20L) // [1L; 20L; 2L; 10L; ...] // Ah ha!