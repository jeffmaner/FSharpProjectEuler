module Problem37

// Find the sum of all eleven primes that are both truncatable from left to right and right to left.
//
// The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove
// digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work
// from right to left: 3797, 379, 37, and 3.
//
// Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
//
// NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.


// I don't like any of the code from my normal sources. But Math Blog points me to a Python solution that
// is interesting.


// From http://blog.dreamshire.com/2009/04/23/project-euler-problem-37-solution/:
// When a prime number, greater than 100, is truncated, it can’t be composed of any digits from the set
// {2, 4, 5, 6, 8, 0} or the truncated number would be composite. Further, it can’t start or end with 1 or 9
// or a truncated version would end up being composite. Finally, any prime having pairs as ’11′, ’33′, ’77′
// or ’99′ would eventually be divisible by 11 and therefore composite.
//
// By applying this observation, we could truncate(sorry) our original list of primes from 78,473 to 65
// primes. After looking at the list you immediately see you could eliminate entries ending in 93 or
// beginning with 39 leaving only 40 primes left to check. You could keep going and easily solve this one by
// hand.


let eSieve limit =
    seq{yield 2 // First prime.
        let knownComposites = new System.Collections.Generic.HashSet<int>()
        for i in 3..2..limit do // Loop through all odd numbers--evens can't be prime.
            // If it's not in our list, it's prime.
            if not (knownComposites.Contains(i)) then
               yield i

            // Add all multiples of i to our sieve, starting at i
            // and incrementing by i.
            do for j in i..i..limit do
                   knownComposites.Add(j) |> ignore}

let ps = eSieve 1000000 |> Seq.toArray
// Real: 00:00:02.822, CPU: 00:00:02.589, GC gen0: 121, gen1: 2, gen2: 2

let isPrime n = System.Array.BinarySearch(ps, n) > 0 //ps |> Seq.exists (fun p -> p=n)

// This list of primes was generated by the regex
// @p = grep {!/[024568]/ && !/99|77|33|11/ && !/^[91]/ && !/[91]$/ && !/93$/ && !/^39/} @primes;
// with the additional comment:
// We didn’t forget to add the two-digit truncatable primes. We found them by hand: 23, 37, 53, 73.
let primes = [23;37;53;73;313;317;373;797;3137;3797;7937;31397;31973;37313;37397;71317;
              71713;71917;73973;79397;313717;317197;319313;371737;371797;373717;373937;
              379397;713737;713917;717317;717397;717917;719197;719713;719717;731713;
              731737;739373;739397;791317;791797;793717;797917]
// Real: 00:00:00.007, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0

// From http://blog.dreamshire.com/2009/04/23/project-euler-problem-37-solution/:

let trunc n =
    let mutable c = n
    let mutable m = n
    let mutable r = true
    while c>10 do
          c <- c % (pown 10 (int (log10 (float c))))
          m <- m/10
          if not (isPrime c) || not (isPrime m) then r <- false
    r && true

let mutable c = 0
let mutable s = 0

for p in primes do
    if trunc p then
       c <- c+1
       s <- s+p
// Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0

printfn "%d" s // 748294. Correct answer is 748317. A difference of 23. How am I missing the first one?
// Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0

printfn "%d" c //10. Missing one.
// Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0