module Problem44

// Find the smallest pair of pentagonal numbers whose sum and difference is pentagonal.
// 
// Pentagonal numbers are generated by the formula, P(n)=n(3n−1)/2. The first ten pentagonal numbers are:
// 
// 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
// 
// It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). However, their difference, 70 − 22 = 48, is not
// pentagonal.
// 
// Find the pair of pentagonal numbers, P(j) and P(k), for which their sum and difference is pentagonal and
// D = |P(k) − P(j)| is minimised; what is the value of D?


// Based on http://theburningmonk.com/2010/09/project-euler-problem-44-solution/:

// The Pentagonal function.
let P n = n*(3*n-1)/2

let cache = new System.Collections.Generic.Dictionary<int,int>()
[1..5000] |> List.iter (fun n -> cache.[n] <- P n)
// Real: 00:00:00.002, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0

let isPentagonal n = cache.ContainsValue n

// Determines whether P(k) and P(j)'s sum and diff are both pentagonal.
let predicate (k,j) =
    let pk = cache.[k]
    let pj = cache.[j]
    isPentagonal (pj+pk) && isPentagonal (pk-pj)

// The sequence of k,j pairs to check.
let kjSeq =
    [1..5000] // I don't know where the limit of 5000 comes from.
    |> List.collect (fun k -> [1..k-1] |> List.rev |> List.map (fun j -> (k,j)))
// Real: 00:00:06.485, CPU: 00:00:06.770, GC gen0: 194, gen1: 76, gen2: 2

// Get the first pair of k,j whose sum and difference are both pentagonal.
let (k,j) = kjSeq |> Seq.filter predicate |> Seq.head // (2167,1020).
// Real: 00:00:56.654, CPU: 00:00:56.534, GC gen0: 0, gen1: 0, gen2: 0

let answer = (P k) - (P j) // 5482660.
// Real: 00:00:00.000, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0


// From http://fsharp-euler.wikispaces.com/euler+044:

let crossproduct l1 l2 =
    seq {for el1 in l1 do
             for el2 in l2 do
                 yield el1, el2}

let problem44 =
    let pents = [1..5000] |> List.map (fun v -> v*(3*v-1)/2) // I don't know where the limit of 5000 comes from.
    let isPent n =
        let k = (sqrt (float n * 24. + 1.) + 1.) / 6. // This is the inverse of the Pentagonal function.
        abs (float (int k) - k) < 1e-5                // Checking to make sure the inverse results in an integer.
    crossproduct pents pents |> Seq.filter (fun (a,b) -> isPent(a-b) && isPent(a+b)) |> Seq.toList // [(7042750, 1560090)].
// Real: 00:00:11.232, CPU: 00:00:11.668, GC gen0: 255, gen1: 4, gen2: 1
// That's quite a time difference!
